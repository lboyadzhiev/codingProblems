JS
    PRIMITIVE VS. REFERENCE TYPES

        Primitive data types 

            - Number;
            - String;
            - Boolean;
            - Undefined;
            - Null;
            - Symbol;
            - BigInt;
        
        Reference data types 

            - Objects:
                - Object literal;
                - Arrays;
                - Functions;
                - ect...

        Js Engine

            The JS Engine has two components: 
             
                - Call Stack;
                    Where functions are executed, and primitive types are stored. Here execution context run.

                    When we declare a primitive type JS creates a unique identifier call variable name, then a piece of memory will be alocated with a certain address, then the value will be stored in memory with the specifyed address.
                    !! Identifier point to the addres not to the value. Adress is imutable, so it can't be changed. If we change the value of the variable it create new address where it is stored.

                - Heap;
                    Reference type are stored in memory. When a new object is created it is stored in the HEAP. And such as before there is memory address and value. The object identifieer does not point to directly in memory address in the Heap, instead it is point to the new piece of memory created in the STACK. and then this piece of memory point to the object address in the HEAP, by usin a memory address as it's value. 
                    The piece of memory in the callStack has the piece of memory in the Heap wich holdes the object. That is becouse the objects can be a large the heap is unlimited.

            

    OBJECTS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        Everything in JS is object.

        WHAT IS OBJECT?
            An object is a collection of fields, and a field is an association between a name(or key) and value.
            A filed's value can be a fucntion, in which case it is known as method.
            Objects are a reference data type, safe in HEAP.
        
        DEFINING OBJECTS  

            1. create a JS object with an "object literal {}"

                    let object = {key: value, key: value};
                
        ASSIGNING AND ACCESSING PROPERTIES (key or value)
 
            1. Simple dot-notation

                let object = {};
                object.key = value;
            
            2. Bracket-notation 

                object["key"] = value; 

                ! Use it when we have spaces in key.

        OBJECT METHODS

            Methods are actions that can be performed on objects.
            Methods are stored in properites as fucntion definition.

            ! We can't use lambda function, in JS this type of functions have explicity assignment this and it can't be changed. 


            let object = {
                keyOne: valueOne,
                keyTwo: valueTwo,
                keyThree: fucntion () {
                    return this.keyOne + '' + this.keyTwo;
                }
            }
            
            console.log(object.keyThree()); // valueOne valueTwo

        WHAT IS "this" KEYWORD

            In JS 'this' means context. This context is execution. Every function in JS has execution context and execution scope(lexical scope). The 'this' keyword refers to the current object the code is being written inside. This will always ensure that the correct values are used when a member's context changes. Arrow functions does not get own "this" keyword! The arrow function use lexical "this" that mean it use the "this" keyword from the parent scope. 

                <script>
                    const objOne = {
                        kyeOne: valueOne,
                        keyTwo: valueTwo,
                        method: function () {
                            console.log(this.keyOne - this.keyTwo);
                        }
                    }

                    objOne.method();

                    const objTwo = {
                        keyOne: vlaueOne,
                        keyTwo: valueTwo
                    }

                    objTwo.method = objOne.method;

                    objTwo.method();
                </script>

            The "this" keyword will point to the object that is calling the method.  In this example the objTwo is calling the mothod, so the "this" keyword that is isnide the method is pointing to the objTwo keys.
            If we have fucntion in method, the "this" keyword does not work in the function, so we can solve this problem by making a variable outside the fucntion wich is equal to 'this', ot we can use an Arrow Fucntion (the arrow function does not have own "this" keyword, and use "this" from the parent scope).

            NOTE:Wen we coppy one method to another we don't call it "()".

        COMPARING OBJECTS

            Two variables, two distinct objects with the same properites.

                let objectOne = {keyOne: "valueOne"};
                let objectTwo = {keyTwo: "valueTwo"};

                objectOne == objectTwo; // return false

            Two variables, a singe object

                let objectOne = {keyOne: "valueOne"};
                let objectTwo = objectOne; // Assign objectOne reference to objectTwo

                Here the two variables are pointing to same object

                objectOne == objectTwo; // return true

        INTERNAL PROPERTIES

            Every object field has four properites:

                1. Enumerable - can access to all of them using a for...in loop. Also, enumerable property keys of an object are returned using "Object.keys" method;
                2. Configurable - can modify the behavior of the property, so you can make them non-enumerable, non-writeble or even non-configurable;
                    -- We can delete only configurable properites;
                3. Writable - can modify their values and update a property just assigning a new value to it;
                4. Value 


                    let obj = {};

                    Object.defineProperties (
                        obj,
                        {
                            "key": {
                                get: () => {  },
                                set: () => {  },
                                //configurable: true,
                                //enumerable:false,
                                //writeble: false,
                                //value: some value
                            }
                        }
                    )

                "get" "set"

                "set" - can be only fucntion that have param
                "get" - can be fucntion as well


        LOOPING THROUGH OBJECTS

             Objects are looping through keys.

             "Object keys" - we take the keys, return Array. It is good practise when we take the keys from object to check if they are keys from this object "hasOwnProperty". 

             "Object values" - return values from the object.

             "for...in Loop" - iterates a specified variable over all the enumerable properites of an object.
             "for...of Loop" - creates a loop iterating over iterable objects.

        JSON

            A common use of JSON is to read data from a web server, and display the data in a web page.

            PARSING FROM STRINGS

                Use JS built-in function "JSON.parse()" to convert the string into a JS object.

                let obj = JSON.parse(text);

            CONVERT TO STRING

                Use "JSON.stringify()" to convert objects into a string.

                let obj = {key: value}
                let objJSON = JSON.stringify(obj);

                we can do the same for arrays.

        ! rownd to the second number  - Math.floor(value * 100) / 100;





    We can't add "removeEventListener" to a function, so we make variable.

        Debugging in Chrome 

            1. open devtools - ctr + shift + j
            2. click "Sources";

        what is "bind"?

            1. Bind an object to a function;
            2. Reference it using 'this';

    FUNCTIONS //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        Functions are one of the fundamental building blocks in JS. A fucntion in JS is similar to a procedure - a set of statements that performs a task, take some input and return an output where there is some abvious relationship between the input and the output. To use a fucntion, we must define it somewhere in the scope from which we wish to call it.

            -- Fucntion Declaration

                The fucntion declaration defines a fucntion with the specified parameters.

                    <script>

                        fucntion name(params) {
                            [statements]
                        }

                    </script>

                "name" - the fucntion name;

                "params" - optional. The name of an argument to be passed to hte fucntion.

                "statements" - the statements which comprise the body of the fucntion.

                A fucntion created with a fucntion declaration is a Function object and has all the porperties, methods and behavior of Fucntion object.

                By default, fucntions return 'undefined'. To return any other value, the fucntion must have a 'retur' statement that specifies the value to return.

                Hoisting!!!

                    Function declaration in JS are hoisted to the top of the enclosing fucntion or global scope. That is mead we can use the function before we declare it.
            

            -- Function Expression

                A fucntion Expression is very similar to and almost the same syntax as fucntion declaration. The main difference is the function name. which can be omitted in fucntion expression to create anonymous fucntions.

                    const name = fucntion(param) {
                        statements
                    }

                Hoisting!!!

                    Fucntion expression in JS are not hoisted. We can't use fucntion expression before we create them.

            -- Arrow Function   

                Comparing traditional functions to arrow functions.

                    // Traditioanl Anonymous Function

                        <script>

                            function (a) {
                                return a + 100;
                            }

                        </script>

                    // Arrow fucntion break down

                        // 1. Remove the word "function" and pleace arrow between the argument and opening body bracket:

                            <script>

                                (a) => {
                                    return a + 100;
                                }

                            </script>

                        // 2. Remove the body braces and word "return" -- the return in implied.

                            <script>
                                (a) => a + 100;
                            </script>

                        // 3. Remove the argument parantheses

                            <script>
                                a => a + 100;
                            </script>

                        The { braces } and (parantheses) and "return" are required in some cases. 
                            - If we have multiple arguments, we will need to re-introduce parantheses around the arguments.
                            - If the body requires additional lines of processing, we will need to re-introduce braces plush the "return".

                                <script>
                                    (a, b) => {
                                        let chuck = 42;
                                        return a + b + chuck;
                                    }
                                </script>
                        
                        For named fucntions we treat arrow expressions like varibales:

                            <script>
                                let bob = a => a + 100;
                            </script>

                        To return an object literal expression requires parentheses around expression:

                            <script>
                                params => ({foo: "a"});
                            </script>

                        Rest parameters are supported: 

                            (a,b, ...r) => expression;
                        
                        Default parameters are supported:

                            (a=400, b=20, c) => expression;

                        Destructuring within params supported:

                            ([a, b] = [10, 20]) => a + b; // result is 30;
                            ({ a, b } = { a: 10, b:20 }) => a + b; // result is 30;

                        Arrow function is not ok for methods, it has no own "this" keyword. Use his parrent 'this'.


